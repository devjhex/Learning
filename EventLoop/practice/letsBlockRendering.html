<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Rendering</title>

    <style>
    #box {
      width: 50px;
      height: 50px;
      background: red;
      position: absolute;
      animation: move 2s linear infinite;
    }

    @keyframes move {
      from { left: 0; }
      to { left: 300px; }
    }
  </style>
</head>
<body>
    
<button id="btn">Block 2 Seconds</button>
<div id="box"></div>

<script>
  const btn = document.getElementById('btn');

  /* btn.onclick = () => {
    const start = performance.now();
    while (performance.now() - start < 2000) {
      // block main thread for 2 seconds // no code and this is not becuase this is heavy it is because the loop is running and the main thread is busy executing this loop and it cannot do anything else until this loop finishes
    }
  }; */

  btn.onclick = (chunckedWork(2000));

  function chunckedWork (duration){
    const start = performance.now();
    
    function doChunk() {
      if (performance.now() - start < duaration) {
        //do a small chunk of work
        setTimeout(doChunk, 0); // schedule the next chunk
    }
    
    doChunk();
  }}

  /* 

  YES. üòÑ
That excitement? Keep it. That‚Äôs your brain wiring the model correctly.

You just connected:
	‚Ä¢	60fps ‚âà 16.6ms per frame
	‚Ä¢	If JS blocks 200ms ‚Üí ~12 frames gone
	‚Ä¢	rAF runs once per frame
	‚Ä¢	No frame ‚Üí no rAF
	‚Ä¢	No rAF ‚Üí no animation update

That‚Äôs the full chain.

That‚Äôs not surface understanding anymore. That‚Äôs systems thinking.

‚∏ª

Let‚Äôs sharpen it one tiny bit so it‚Äôs crystal clear:

When you block for 200ms:

It‚Äôs not that the browser decides to skip frames.

It literally cannot start a new frame because:

The main thread is still executing your click handler.

A frame cycle roughly looks like:

‚Üí Run one task
‚Üí Drain microtasks
‚Üí Run rAF callbacks
‚Üí Layout
‚Üí Paint
‚Üí Composite

If you‚Äôre still stuck inside:

Run one task

The browser never reaches:

Run rAF callbacks

So it never reaches paint.

So visually:
Everything freezes.

Then once the block ends,
the browser finally reaches rendering,
and the animation jumps to its new computed position.

‚∏ª

The coolest part?

CSS animations feel like magic,
but they still rely on:
	‚Ä¢	style recalculation
	‚Ä¢	layout
	‚Ä¢	paint

And those need the main thread.

So JS and rendering are not separate worlds.
They share the same road.

If one blocks the road,
the other waits in traffic.

‚∏ª

Now here‚Äôs where it gets even more interesting.

Remember your earlier thought:

If we used await new Promise(resolve => setTimeout(resolve, 2000))

That does NOT block the main thread.

Why?

Because:
	‚Ä¢	The click handler returns immediately after hitting await
	‚Ä¢	The rest of the function is scheduled as a microtask
	‚Ä¢	The 2-second delay happens in the timer system (outside JS execution)
	‚Ä¢	The main thread is free during that time

So animation continues smoothly.

That‚Äôs the massive difference between:

Busy-wait loop
vs
Asynchronous pause

Same delay duration. Completely different impact.

‚∏ª

You‚Äôre now seeing something big:

‚ÄúBlocking‚Äù is not about time passing.

It‚Äôs about holding the main thread hostage.

Two seconds can pass without freezing anything.
Or 200ms can freeze the UI.
Depends on whether the thread is occupied.

‚∏ª

You‚Äôre in a very good mental zone right now.

Want to go one level deeper and talk about why sometimes even await can still cause microtask starvation? Or should we run the animation experiment first and observe it live?
  
  */
</script>
</body>
</html>