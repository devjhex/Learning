## Parsing
What exactly blocks HTML parsing?
-- Javascript.

why does normal <script> block parsing but defer does not?
-- defer is a special keyword that hints to the browser that the script is not needed at that point so blocking the thread and executing that script or even loading it can be skipped for now. That's why defer does not block parsing.

What happens if CSS is still loading but JS wants to read layout?
-- Javascript is blocked until the CSS is finished loading and this is because the CSSOM is not yet built and it should get things right so Javascript has to wait "Sorry JS"

What trees exist after parsing?
-- DOM, CSSOM, Layout tree, Layer tree
NOTE:
-- JS does have a Abstract Syntax Tree generated by the JS engine but its separate from the rendering trees. The AST is for execution while the DOM/CSSOM/layout trees are for rendering.

Why are DOM + CSSOM still not enough for render?
-- DOM + CSSOM only give the element's themselves and the computed styles, like color, size etc but they dont give how the elements are to be drawn and also what order the elements are to be rendered.


## Style layout, paint, Main thread work
What is style calculation really doing?
-- calculating styles of each element in the DOM.

Why is layout expensive?
-- Because changing one element can force the browser to recalculate the size and position of many other elements, sometimes the entire page. Eg what is the size of the container...
Answer : Depends on .container
        which depends on parent
        which depends on viewport size
        which depends on zoom level
        which depends on device...

What is layout tree vs DOM tree?
-- Layout tree is as a result of style calculation that is from the DOM + CSSOM, while the DOM tree is from raw HTML.

Why can reading layout force synchronous layout (layout thrashing)?
-- It is because JavaScript is asking the browser a question that can only be answered if layout is fully up to date and the browser is not allowed to lie.
    Example : 
    Imagine you write something like this : el.offsetWidth
    You just asked "What is the actual width right now?"
    -- But layout is dirty so it one of 2 options:
        - Return a stale value(not allowed)
        - Force layout immediately
    So it: 
    - Flushes style calculation
    - Runs layout synchronously
    - Returns the value

    It can't delay the task because JS is single threaded and synchronous so that force just had to happen.

What is layout thrashing?
-- Layout thrashing is when JS repeatedly causes the browser to flush layout or causes it repeatedly synchronosly recalculate layout within a single task by interleaving layout reads, and layout writes.

What are paint records exactly? (hint they are instructions not pixels)
-- They are instructions about how and in what order elements should be drawn on the page.

## Layering (Critical transition point)
Who decides which elements become layers?
-- The main thread

Why not everything become a layer?
-- it rasterizing small parts of a page and compositing those parts is faster and if everything is a layer rasterizing those parts could be slow.

What kinds of things usually promote a layer?
-- transforms, opacity, will-change attribute, etc.

What problem is layering solving (hint : avoiding repaint)
-- The browser had no way to change or animate a part of a page or the whole page without actually repainting EVERYTHING.

What is the difference between layer tree from layout tree?
-- The layout tree contains atleast all the elements as in how they will be drawn on the screen, postitions, co-ordinates, while the layer tree contains only elements that are considered to be layers and those are selected by the main thread or the developer if they choose to hint that they should be separate layers to be sent to the compositor thread.

## Compositing
What is rasterization? (hint: turning paint instructions into bitmaps)
    - Rasterization is the process of turning vector graphics (layout, shapes, CSS styles, text) into actual pixels (bitmaps) that the GPU can display on the screen.
    Why is rasterization expensive?
        1️⃣ Large number of pixels
            •	Modern screens have millions of pixels (1080p = ~2 million, 4K = ~8 million).
            •	Rasterizing means calculating color for every single pixel in each layer/tile.
            •	More pixels → more computation.

        ⸻

        2️⃣ Complex elements
            •	CSS effects: shadows, gradients, border-radius, transforms
            •	Fonts / text rendering: anti-aliasing, sub-pixel rendering
            •	Images / alpha blending: combining layers

        All of these require per-pixel math, which adds up quickly.

        ⸻

        3️⃣ Multiple layers / tiles
            •	Layers are split into tiles for parallel processing.
            •	Each tile is rasterized individually → overhead of memory + CPU/GPU work.

        ⸻

        4️⃣ Dynamic changes
            •	Animations, scrolling, or JS updates may invalidate layers.
            •	Invalidated layers must be rasterized again.
            •	If you do too many changes per frame → too many rasterizations → frame drops.

        ⸻

        5️⃣ Memory / GPU transfer
            •	Raster threads create bitmaps in GPU memory.
            •	Copying large bitmaps → costly.
            •	The bigger the layer or more tiles → more memory bandwidth used.

Rasterization is expensive because it computes the color of every pixel in a layer, often with complex styles and effects, which takes significant CPU/GPU time and memory bandwidth.

Why does the browser tile layers?
    Effecient memory usage
    - The browser tiles layrs because the layers are sometimes large as in very large hence breaking them down into smaller parts which would be better performance

    Rasterize what is visible
    - The viewport as well we want the most importatnt stuff that is what we want to see

    Multi resolution support
    - Layers may have different resolutions for zooming or high-DPI screens

    Fast invalidation
    - Only affected tiles need re-rasterization
    - The rest stay in GPU memory


What does raster threads actually do?
    - The raster threads compute the vector graphics into bitmaps and send them to the GPU.

Where do bitmaps live?
    - They are stored in the GPU memory.


## Compositor thread
What are draw quads?
    - This is information such as the tile's locaiton in memory, where in the page to draw the tile taking into consideration the page compositing.

What does a compositor thread contain?

    - 1️⃣ Layer tree
	•	The main thread sends layer tree info to the compositor thread
	•	Which DOM elements became layers
	•	Their positions, transforms, opacity, stacking order
	•	Each layer can have one or more tiles (from raster threads)
	•	Layer tree = blueprint for how the page should appear

⸻

    2️⃣ Draw quads
        •	After raster threads create bitmaps for each tile, the compositor thread collects them into draw quads
        •	Draw quad = a small rectangle with:
        •	A reference to the bitmap
        •	Where it should be drawn in the layer
        •	Any transforms/opacity effects
        •	Draw quads are the instructions the GPU needs to composite the frame

    ⸻

    3️⃣ Compositor frames
        •	Compositor thread assembles all draw quads for all layers into a compositor frame
        •	A compositor frame = everything the GPU needs to render one frame of the page
        •	Can include:
        •	Page content
        •	Browser UI (tabs, scrollbar)
        •	Layers from other renderer processes (extensions, iframes)

    ⸻

    4️⃣ Event handling / input coordination
        •	Compositor thread handles:
        •	Fast scrolling / panning
        •	Pinch zoom
        •	Touch gestures
        •	It decides if input can bypass the main thread (passive, non-cancelable, fast-scrollable regions)
        •	Sends relevant input to main thread if JS needs to know

    ⸻

    5️⃣ Scheduling / prioritization
        •	Prioritizes which tiles to raster first (viewport first)
        •	Handles multi-resolution tilings (high-res vs low-res)
        •	Ensures smooth scrolling/animations

Why is it that transforms and opacity animations dont need repaint?
    - First, these properties can be applied after rasterization.
    - Transforms and opacity animations don’t need repaint because they only affect how existing rasterized layers are composited by the GPU, avoiding layout, paint, and rasterization work.

How does scrolling happen without the main thread?
    - Scrolling can happen entirely on the compositor thread (and GPU) if JS doesn’t need to intervene.

    Conditions for main-thread-free scrolling
    - Fast scrollabe region
    - No JS blocking
    - Cancelable events handled properly


## GPU and Frames
What is sent to GPU?
    - Bitmaps from the raster threads are sent to the GPU.

Why each renderer doesn't own its own GPU?
    - Each renderer doesn’t own its own GPU because GPU resources are limited; the compositor thread lets multiple renderers share the same GPU efficiently and safely.
    - The GPU is insanely fast and can handle a lot of the what the renderer can give it.

How are multiple frames are merged?
    - How merging happens
	•	The GPU doesn’t just draw everything blindly
	•	The compositor thread builds final draw quads for all layers/frames:
	•	Each draw quad references a bitmap tile and position/transform/opacity
	•	GPU executes these quads in order:
	•	Draw tabs → draw page → draw iframe → draw overlays → etc.
	•	Result = merged, final image on the screen

Why do dropped frames cause jank?
    - They cause jank because the rendering pipeline has been interrupted during these frames and they haven't painted so there was no painting in those frames hence jank.

What does 60Hz/120Hz actually mean in practice?
    - It means refreshing the scren 60 times a second or 120 times a second and that's fast enough for the human eye to see it as an animation unless there is some jank.




