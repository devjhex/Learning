<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Event Coalescing in Practice</title>
</head>
<body>
    <div id="box" style="width:50px;height:50px;background:red;position:absolute;"></div>

    <script>

    document.addEventListener("pointermove", e => {
        const start = performance.now();
        while (performance.now() - start < 20) {
          // intentionally block main thread
        }

        console.log(e.getCoalescedEvents().length);
      });

    /* Fast path vs Non-fast path scrolling

Fast scrollable region âœ…

The compositor can scroll without consulting the main thread if all are true:
	â€¢	No listener that can cancel the scroll
	â€¢	Or the listener is passive: true
	â€¢	Or CSS touch-action says scrolling behavior is fixed

â¡ï¸ Result:
	â€¢	Scroll handled entirely by compositor
	â€¢	Events may be coalesced
	â€¢	Main thread is not in the critical path

â¸»

Non-fast scrollable region âŒ

This happens when:
	â€¢	There exists a listener that might cancel scrolling
	â€¢	Example: touchmove, wheel, pointermove without passive: true

Even if your JS never calls preventDefault.

â¡ï¸ Result:
	â€¢	Compositor must wait for the main thread
	â€¢	Scrolling becomes main-thread dependent
	â€¢	Coalescing still happens, but dispatch is delayed until rAF 

    Even if your JS never calls preventDefault.


    Why the compositor has to â€œaskâ€ the main thread

Because from the compositorâ€™s point of view:
	â€¢	JS might:
	â€¢	call preventDefault()
	â€¢	change scroll behavior
	â€¢	read layout
	â€¢	mutate DOM

The compositor cannot predict JS behavior.

So it delays:
	1.	Input arrives (wheel / touch / pointer)
	2.	Compositor buffers / coalesces events
	3.	Right before the next requestAnimationFrame
	4.	Dispatches them to the main thread
	5.	If JS does nothing â†’ scroll proceeds
	6.	If JS cancels â†’ scroll is stopped
*/

/* 
 Perfect â€” this is exactly the right moment to pin it down cleanly and concretely.
Letâ€™s reset and describe when event coalescing actually happens in real time, no fuzz.

â¸»

One-sentence truth (anchor this)

Event coalescing happens when multiple raw input events arrive faster than the main thread can (or should) process them before the next animation frame.

Thatâ€™s it. Everything else is detail.

â¸»

Real-time timeline (step by step)

Assume a 16.6ms frame budget (60Hz).

1ï¸âƒ£ Hardware generates raw events

Your mouse / touchpad / finger produces events like:

t=0ms   pointermove #1
t=1ms   pointermove #2
t=2ms   pointermove #3
t=3ms   pointermove #4
...

These are raw â€” not JS yet.

â¸»

2ï¸âƒ£ Browser decides: â€œdispatch now or wait?â€

Chrome asks:
	â€¢	Is the main thread free right now?
	â€¢	Are we close to the next frame boundary?
	â€¢	Is this a high-frequency event?
	â€¢	Would dispatching each event waste time?

If YES, dispatch immediately (no coalescing).
If NO, queue & coalesce.

â¸»

3ï¸âƒ£ Coalescing phase (this is the key moment)

Instead of doing:

dispatch(pointermove #1)
dispatch(pointermove #2)
dispatch(pointermove #3)
dispatch(pointermove #4)

Chrome does:

keep latest state
store intermediate states internally

No JS runs yet.

âš ï¸ Important:
	â€¢	Events are not lost
	â€¢	Theyâ€™re merged

â¸»

4ï¸âƒ£ Right before the next rAF âœ¨

This sentence confused you earlier â€” now it should click:

â€œDispatched right before the next requestAnimationFrame.â€

Meaning:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€ Frame N â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ input â†’ coalesce        â”‚
â”‚ input â†’ coalesce        â”‚
â”‚ input â†’ coalesce        â”‚
â”‚                         â”‚
â”‚ â–¶ DISPATCH EVENT â—€     â”‚  â† JS runs here
â”‚ â–¶ rAF callback â—€       â”‚
â”‚ style/layout/paint      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

So:
	â€¢	JS sees 1 event
	â€¢	That event may contain many raw events

â¸»

5ï¸âƒ£ JS runs (this is â€œdispatchâ€)

Now your handler finally runs:

element.addEventListener("pointermove", e => {
  console.log(e.getCoalescedEvents().length);
});

	â€¢	If main thread was free earlier â†’ length = 1
	â€¢	If under pressure â†’ length = 5, 10, 20, etc.

â¸»

Why coalescing is done (real reason)

Because running JS like this:

input â†’ JS â†’ layout â†’ paint
input â†’ JS â†’ layout â†’ paint
input â†’ JS â†’ layout â†’ paint

would:
	â€¢	Blow the frame budget
	â€¢	Starve rendering
	â€¢	Kill scrolling

Coalescing turns it into:

many inputs â†’ 1 JS â†’ 1 paint


â¸»

When coalescing does NOT happen

Very important:
	â€¢	Main thread idle âœ…
	â€¢	Light page âœ…
	â€¢	Low input rate âœ…

Then Chrome just dispatches immediately.

Thatâ€™s why you saw getCoalescedEvents() return 1.

Nothing to merge.

â¸»

When coalescing definitely happens
	â€¢	Heavy JS
	â€¢	Long tasks
	â€¢	Logging in handlers
	â€¢	Layout reads
	â€¢	Multiple listeners
	â€¢	DevTools open ğŸ˜„

â¸»

Final mental model (short)

Raw events happen continuously.
JS events happen at most once per frame.
Coalescing is how Chrome enforces that.

â¸»

If you want next, we can:
	â€¢	Draw the exact order: input â†’ rAF â†’ style â†’ layout
	â€¢	Or compare coalescing vs throttling vs debouncing
	â€¢	Or show how games use coalesced events properly

Just say the word ğŸ‘Œ

What Chrome does:

1ï¸âƒ£ It dispatches at most ONE event in that frame
	â€¢	That single dispatch contains:
	â€¢	the latest state
	â€¢	all coalesced raw events so far

2ï¸âƒ£ Any new raw events that arrive after dispatch
	â€¢	Are queued for the next frame
	â€¢	Not added to the already-dispatched event

3ï¸âƒ£ Next frame:
	â€¢	Browser repeats the process
	â€¢	New dispatch
	â€¢	New getCoalescedEvents() array
*/

   

    </script>
</body>
</html>